



题：
给出两个非空的链表用来表示两个非负的整数。
其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);
        ListNode* h = head;  //移动指针
        int sum = 0;
        bool carry = false;     //满十进一标志位
        while(l1 != NULL || l2 != NULL)
        {
            sum = 0;
            if(l1 != NULL)
            {
                sum += l1->val;
                l1 = l1->next;
            }

            if(l2 != NULL)
            {
                sum += l2->val;
                l2 = l2->next;
            }

            if(carry)
                sum++;
            
            h->next = new ListNode(sum % 10);
            h = h->next;
            carry = (sum >= 10) ? true:false;
        }

        if(carry)
            h->next = new ListNode(1);

        return head->next;
    }
};


题：最接近的三数之和
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。
返回这三个数的和。假定每组输入只存在唯一答案。

暴力枚举的话时间复杂度会到O(n^3)，需要降低时间复杂度
可以用排序加双指针的方法：
首先进行数组排序，时间复杂度为O(nlogn)
在数组中进行遍历，每遍历一个值利用其下标i，形成一个固定值nums[i]，再使用前指针指向start=i+1处，后指针指向end=nums.length-1
处，也就是结尾处。sum=nums[i]+nums[start]+nums[end]，如果sum大于target，end--，否则start++；如果sum=target直接返回结果

class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int ans = nums[0]+nums[1]+nums[2];
        int sum;

        for(int i = 0; i < nums.size() - 2; i++)
        {
            int start = i + 1;
            int end = nums.size() - 1;
            while(start < end)
            {
                sum = nums[i] + nums[start] + nums[end];
                if(abs(sum - target) < abs(target - ans))
                    ans = sum;
                
                if(sum > target)
                    end--;
                else if(sum < target)
                    start++;
                else
                    return ans;
            }
        }

        return ans;
    }
};


题：给定一个二叉树，返回它的中序遍历
递归算法很简单，你可以通过迭代算法完成吗？

前序遍历迭代算法：
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> S;
        vector<int> v;
        TreeNode* rt = root;
        while(rt || S.size()){
            while(rt){
                S.push(rt->right);
                v.push_back(rt->val);
                rt=rt->left;
            }
            rt=S.top();S.pop();
        }
        return v;        
    }
中序遍历迭代算法：
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> S;
        vector<int> v;
        TreeNode* rt = root;
        while(rt || S.size()){
            while(rt){
                S.push(rt);
                rt=rt->left;
            }
            rt=S.top();S.pop();
            v.push_back(rt->val);
            rt=rt->right;
        }
        return v;        
    }
后序遍历迭代算法：
(1):思路： 每到一个节点 A，就应该立即访问它。 然后将左子树压入栈，再次遍历右子树。遍历完整棵树后，结果序列逆序即可。
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> S;
        vector<int> v;
        TreeNode* rt = root;
        while(rt || S.size()){
            while(rt){
                S.push(rt->left);
                v.push_back(rt->val);
                rt=rt->right;
            }
            rt=S.top();S.pop();
        }
        reverse(v.begin(),v.end());
        return v;
    }
(2):思路：每到一个节点 A，因为根要最后访问，将其入栈。然后遍历左子树，遍历右子树，最后返回到 A。但是出现一个问题，无法区分是从左子树返回，还是从右子树返回。
因此，给 A 节点附加一个标记T。在访问其右子树前，T 置为 True。之后子树返回时，当 T 为 True表示从右子树返回，否则从左子树返回。当 T 为 false 时，表示 A 的左子树遍历完，还要访问右子树。
同时，当 T 为 True 时，表示 A 的两棵子树都遍历过了，要访问 A 了。并且在 A 访问完后，A 这棵子树都访问完成了。
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> S;
        unordered_map<TreeNode*,int> done;
        vector<int> v;
        TreeNode* rt = root;
        while(rt || S.size()){
            while(rt){
                S.push(rt);
                rt=rt->left;
            }
            while(S.size() && done[S.top()]){
                v.push_back(S.top()->val);
                S.pop();
            }
            if(S.size()){
                rt=S.top()->right;
                done[S.top()]=1;    
            }
        }
        return v;
}


题：
给定一个字符串，请你找出其中不含有重复字符的最长子串 的长度。
主要用到思路是：滑动窗口
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;
        unordered_set<char> lookup;
        int maxStr = 0;
        int left = 0;
        for(int i = 0; i < s.size(); i++){
            while (lookup.find(s[i]) != lookup.end()){
                lookup.erase(s[left]);
                left ++;
            }
            maxStr = max(maxStr,i-left+1);
            lookup.insert(s[i]);
    }
        return maxStr;
        
    }
};


题：
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
如果对时间复杂度的要求有log，通常都需要用到二分查找，这道题也可以通过二分查找实现。
class Solution {
public:
    int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int m = nums1.size();
        int n = nums2.size();
        int index1 = 0, index2 = 0;

        while (true) {
            // 边界情况
            if (index1 == m) {
                return nums2[index2 + k - 1];
            }
            if (index2 == n) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return min(nums1[index1], nums2[index2]);
            }

            // 正常情况
            int newIndex1 = min(index1 + k / 2 - 1, m - 1);
            int newIndex2 = min(index2 + k / 2 - 1, n - 1);
            int pivot1 = nums1[newIndex1];
            int pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= newIndex1 - index1 + 1;
                index1 = newIndex1 + 1;
            }
            else {
                k -= newIndex2 - index2 + 1;
                index2 = newIndex2 + 1;
            }
        }
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int totalLength = nums1.size() + nums2.size();
        if (totalLength % 2 == 1) {
            return getKthElement(nums1, nums2, (totalLength + 1) / 2);
        }
        else {
            return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;
        }
    }
};



题：最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

方法一：动态规划
对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 {``ababa''}“ababa“,
如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。

注意边界条件：长度为1时的字符显然是回文串；长度为2的字符串若两个字符相同，也为回文串；长度大于2时则通过动态规划得出
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        string ans;
        for (int l = 0; l < n; ++l) {
            for (int i = 0; i + l < n; ++i) {
                int j = i + l;
                if (l == 0) {
                    dp[i][j] = 1;
                } else if (l == 1) {
                    dp[i][j] = (s[i] == s[j]);
                } else {
                    dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);
                }
                if (dp[i][j] && l + 1 > ans.size()) {
                    ans = s.substr(i, l + 1);
                }
            }
        }
        return ans;
    }
};

方法二：中心扩展法
class Solution {
private:
    string centerSpread(string s, int left, int right) {
        // left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数
        // right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数
        int size = s.size();
        int i = left;
        int j = right;
        while (i >= 0 && j < size) {
            if (s[i] == s[j]) {
                i--;
                j++;
            } else {
                break;
            }
        }
        // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j
        return s.substr(i + 1, j - i - 1);
    }

public:
    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size < 2) {
            return s;
        }

        int maxLen = 1;
        string res = s.substr(0, 1);
        // 中心位置枚举到 len - 2 即可
        for (int i = 0; i < size - 1; i++) {
            string oddStr = centerSpread(s, i, i);
            string evenStr = centerSpread(s, i, i + 1);
            string maxLenStr = oddStr.size() > evenStr.size() ? oddStr : evenStr;
            if (maxLenStr.length() > maxLen) {
                maxLen = maxLenStr.size();
                res = maxLenStr;
            }
        }
        return res;
    }
};


题：Z字形变换
将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
方法一：按行排序
class Solution{
public:
    string convert(const string& s, int numRows){
        if(s.size() == 1) return s;
	
        vector<string> Rows(min(numRows, s.size()));
        bool Goingdown = false;
        int curRow = 0;

        for(char c: s){
            Rows[curRow] += c;
            if(curRow == 0 || curRow == numRows - 1) Goingdown = !Goingdown;
            curRow += Goingdown? 1:-1 ;
        }
        string ret;
        for(string row : Rows) ret += row;
        return ret;
}

方法二：按行访问
class Solution {
public:
    string convert(string s, int numRows) {

        if (numRows == 1) return s;

        string ret;
        int n = s.size();
        int cycleLen = 2 * numRows - 2;

        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j + i < n; j += cycleLen) {
                ret += s[j + i];
                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)
                    ret += s[j + cycleLen - i];
            }
        }
        return ret;
    }
};


题：整数反转
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
反转后的值不能超出32位有符号整数，32位有符号正整数最大为2的31次方-1=2,147,483,647(INT_MAX,Integer.MAX_VALUE)；32位有符号负整数最小为-2的31次方=-2,147,483,648

class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;
            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};


题：字符串转换整数
请你来实现一个 atoi 函数，使其能将字符串转换成整数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：
如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0 。

方法一：正常遍历
class Solution {
public:
    int myAtoi(string str) {
        long  temp=0;
        int k=0;
        while(k<str.size()&&str[k]==' ')k++;
        int flag=1;
        if(str[k]=='-'){
            flag=-1;
            k++;
        }
       else if(str[k]=='+')k++;
        if('9'<str[k]||str[k]<'0')return 0;
        while(k<str.size()&&('0'<=str[k]&&str[k]<='9')){
            temp=temp*10+str[k]-'0';
           if(temp-1>INT_MAX)break;
//两个作用一是简单判断是否越界提前终止，二是可能测试数据会有大于long 型的数据
            k++;
        }
         temp=flag*temp;
         if(temp>INT_MAX)return INT_MAX;
         if(temp<INT_MIN)return INT_MIN;
       return temp;
        
    }
};

方法二：有限状态机
class Automata{
        string state="start";
        unordered_map<string,vector<string>> table={
            {"start",{"start","sign","innum","end"}},
            {"sign",{"end","end","innum","end"}},
            {"innum",{"end","end","innum","end"}},
            {"end",{"end","end","end","end"}}
        };
        //定义状态表
        int get_s(char c){
            if(c==' ')return 0;
            if(c=='+'||c=='-')return 1;
            if(isdigit(c))return 2;
            return 3;
        }
        //将对应字符转化为数字，结合上一状态得到当前状态

        public:
        long long ans=0;
        int sign=1;

        void get(char c){
            state=table[state][get_s(c)];//根据当前状态的不同对数据进行处理
            if(state=="innum"){
                ans=ans*10+c-'0';
               ans= sign==1 ? min(ans,(long long)INT_MAX): min(ans,-(long long)INT_MIN);
            }
            else if(state=="sign"){
                if(c=='-')sign=-1;
            }
        }
};

class Solution {
public:
    int myAtoi(string str) {
        Automata dfa;
        for(char c:str)
        dfa.get(c);
        return dfa.sign*dfa.ans;     
    }
};


题：回文数
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;
    }
};


题：正则表达式匹配
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

方法一：递归回溯法：效率较低

class Solution {
public:
    bool isMatch(string s, string p) {
        if(p.empty())
            return s.empty();
        bool first_match = !s.empty() && (s[0] == p[0] || p[0] == '.');
        if(p.size() >= 2 && p[1] == '*')
            return (bool)(isMatch(s, p.substr(2)) || (first_match && isMatch(s.substr(1), p)));
	//一：*为0个前一个字符，直接删去这个字符加*   二：两字符串首元素匹配，删去s的第一个字符继续匹配
        else
            return (bool)(first_match && isMatch(s.substr(1), p.substr(1)));  //两字符串首字母匹配成功，都删去一个字符
    }
};

方法二：动态规划
class Solution {
public:
    bool first_match(string s, string p, int i, int j)
    {
        return s[i] == p[j] || p[j] == '.';
    }

    bool isMatch(string s, string p) {
        vector<vector<bool>> dp(s.size()+1, vector<bool>(p.size()+1));
        dp[0][0] = true;
        for(int j = 2; j <= p.size(); j++)
        {
            dp[0][j] = p[j-1] == '*' && dp[0][j-2];
        }
        for(int i = 0; i < s.size(); i++)
        {
            for(int j = 0; j < p.size(); j++)
            {
                if(p[j] == '*')
                {
                    dp[i+1][j+1] = dp[i+1][j-1] || (first_match(s,p,i,j-1) && dp[i][j+1]);
                }
                else
                {
                    dp[i+1][j+1] = first_match(s,p,i,j) && dp[i][j];
                }
            }
        }
        return dp[s.size()][p.size()];
    }
};


题：盛最多水的容器
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
思路：双指针，从两边开始，哪边小就移哪边，得到的就是最大的值

class Solution {
public:
    int maxArea(vector<int>& height) {
        auto begin = height.begin();
        auto end = --height.end();
        int ret = 0, tmp;
        while(begin != end)
        {
            tmp = min(*begin, *end)*(end - begin);
            ret = max(ret, tmp);
            if(*begin > *end)
                end--;
            else
                begin++;
        }
        return ret;
    }
};


题：整数转罗马数字
罗马数字包含以下七种字符：
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内
贪心法：应该使用尽可能大的符号，从左侧开始工作。因此，使用贪心算法是有意义的。
贪心算法是一种在当前时间做出最佳可能决策的算法；在这种情况下，它会取出最大可能的符号。
为了表示一个给定的整数，我们寻找适合它的最大符号。我们减去它，然后寻找适合余数的最大符号，依此类推，直到余数为0。

class Solution {
public:
    string intToRoman(int num) {
        //用数组比用容器内存消耗更少
        int nums[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        string strs[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        string ans;
        int size = sizeof(nums)/sizeof(nums[0]);
        for(int i = 0; i < size; i++)
        {
            while(num >= nums[i])
            {
                ans.append(strs[i]);
                num -= nums[i];
            }
        }
        return ans;
    }
};


题：罗马数转整数
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char,int> mp = {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int ret = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(mp[s[i]] < mp[s[i+1]])
                ret -= mp[s[i]];
            else
                ret += mp[s[i]];
        }
        return ret;
    }
};

数组效率高
class Solution {
public:
    int romanToInt(string s) {
        int mp[90] ={};
        mp['I'] = 1;
        mp['V'] = 5;
        mp['X'] = 10;
        mp['L'] = 50;
        mp['C'] = 100;
        mp['D'] = 500;
        mp['M'] = 1000;

        int ret = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(mp[s[i]] < mp[s[i+1]])
                ret -= mp[s[i]];
            else
                ret += mp[s[i]];
        }
        return ret;
    }
};



题：三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
请你找出所有满足条件且不重复的三元组。

方法一：排序加双指针法
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;

        for (int first = 0; first < n; ++first) {
            if (first > 0 && nums[first] == nums[first - 1])
                continue;
            int third = n - 1;
            int target = -nums[first];
            for (int second = first + 1; second < n; ++second) {
                if (second > first + 1 && nums[second] == nums[second - 1])
                    continue;
                while (second < third && nums[second] + nums[third] > target)
                    --third;
                if (second == third) 
                    break;
                if (nums[second] + nums[third] == target)
                    ans.push_back({nums[first], nums[second], nums[third]});
            }
        }
        return ans;
    }
};



题：电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。  数字对应的字母如手机九键
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

方法一：回溯
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> combinations;
        if(digits.empty()) return combinations;
        unordered_map<char,string> phonemap = {
            {'2', "abc"},
            {'3', "def"},
            {'4', "ghi"},
            {'5', "jkl"},
            {'6', "mno"},
            {'7', "pqrs"},
            {'8', "tuv"},
            {'9', "wxyz"}
        };

        string combination;
        backtrack(combinations, combination, 0, phonemap, digits);
        return combinations;

    }

    void backtrack(vector<string>& combinations, string& combination, int index, const unordered_map<char,          string>& phonemap, const string& digits)
    {
        if(index == digits.size())
            combinations.push_back(combination);
        else
        {
            char digit = digits[index];
            const string& letters = phonemap.at(digit);
            for(const char& letter: letters)
            {
                combination.push_back(letter);
                backtrack(combinations, combination, index+1, phonemap, digits);
                combination.pop_back();
            }
        }
    }
};



题：四数之和
给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

思路：跟三数之和类似，排序加双指针

class Solution{
	public: 
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        vector<vector<int> > res;
        if(nums.size()<4)
        return res;
        int a,b,c,d,_size=nums.size();
        for(a=0;a<=_size-4;a++){
        	if(a>0&&nums[a]==nums[a-1]) continue;      //确保nums[a] 改变了
        	for(b=a+1;b<=_size-3;b++){
        		if(b>a+1&&nums[b]==nums[b-1])continue;   //确保nums[b] 改变了
        		c=b+1,d=_size-1;
        		while(c<d){
        			if(nums[a]+nums[b]+nums[c]+nums[d]<target)
        			    c++;
        			else if(nums[a]+nums[b]+nums[c]+nums[d]>target)
        			    d--;
        			else{
        				res.push_back({nums[a],nums[b],nums[c],nums[d]});
        				while(c<d&&nums[c+1]==nums[c])      //确保nums[c] 改变了
        				    c++;
        				while(c<d&&nums[d-1]==nums[d])      //确保nums[d] 改变了
        				    d--;
        				c++;
        				d--;
					}
				}
			}
		}
		return res;
    }
};


题：删除链表的倒数第N个节点
给定一个链表，删除链表的倒数第n个节点，并且返回链表的头节点
注意：输入的链表一般没有虚头节点，可以自己创建
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyNode = new ListNode(0);
        dummyNode->next = head;

        ListNode* first = dummyNode, *second = dummyNode;
        for(int i = 0; i < n; i++)
        {
            second = second->next;
        }
        while( second->next != NULL )
        {
            first = first->next;
            second = second->next;
        }
        first->next = first->next->next;
        return dummyNode->next;
    }
};


题：有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

利用栈就能解决，有点像四则运算
class Solution {
public:
    bool isValid(string s) {
        if(s.length()%2 == 1) return false;
        stack<char> S;
        for(int i = 0; i < s.length(); i++)
        {
            if(s[i] == '{' || s[i] == '(' || s[i] == '[')
                S.push(s[i]);
            else if(s[i] == '}' || s[i] == ')' || s[i] == ']')
            {
                if(!S.empty() && (S.top()+1 == s[i] || S.top()+2 == s[i]))
                {
                    S.pop();
                    continue;
                }
                else
                    return false;
            }
            else
                return false;
        }
        if(S.empty())
            return true;
        else
            return false;
    }
};



题：合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

方法一：递归
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        } else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};

方法二：迭代：两个链表哪个数小取哪个，直到某个链表全部取完
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* preHead = new ListNode(-1);

        ListNode* prev = preHead;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                prev->next = l1;
                l1 = l1->next;
            } else {
                prev->next = l2;
                l2 = l2->next;
            }
            prev = prev->next;
        }
        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev->next = l1 == nullptr ? l2 : l1;
        return preHead->next;
    }
};



题：括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]

回溯法：
class Solution {
    void backtrack(vector<string>& ans, string& cur, int open, int close, int n) {
        if (cur.size() == n * 2) {
            ans.push_back(cur);
            return;
        }
        if (open < n) {
            cur.push_back('(');
            backtrack(ans, cur, open + 1, close, n);
            cur.pop_back();
        }
        if (close < open) {
            cur.push_back(')');
            backtrack(ans, cur, open, close + 1, n);
            cur.pop_back();
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        string current;
        backtrack(result, current, 0, 0, n);
        return result;
    }
};



题：合并k个升序链表
给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。


方法一：两两合并
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};

方法二：分治合并
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};



题：两两交换链表中的节点
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyNode = new ListNode(0);
        dummyNode->next = head;
        ListNode* last = dummyNode, *tmp = head, *start;

        while(tmp != nullptr)
        {
            if(tmp->next == nullptr)
            {
                last->next = tmp;
                return dummyNode->next;
            }
            last->next = tmp->next;
            start = tmp->next->next;
            last->next->next = tmp;
            tmp = start;
            last = last->next->next;
        }
        last->next = nullptr;
        return dummyNode->next;
    }
};



题：K个一组翻转链表
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

class Solution {
public:
    // 翻转一个子链表，并且返回新的头与尾
    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
        ListNode* prev = tail->next;
        ListNode* p = head;
        while (prev != tail) {
            ListNode* nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* hair = new ListNode(0);
        hair->next = head;
        ListNode* pre = hair;

        while (head) {
            ListNode* tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode* nex = tail->next;
            // 这里是 C++17 的写法，也可以写成
            // pair<ListNode*, ListNode*> result = myReverse(head, tail);
            // head = result.first;
            // tail = result.second;
            tie(head, tail) = myReverse(head, tail);
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};



题：删除排序数组中的重复项
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        int j = 0;
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] != nums[j])
                nums[++j] = nums[i];
        }
        return j+1;
    }
};




题：移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

跟上一题差不多：
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int j = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == val)
                continue;
            else
                nums[j++] = nums[i];
        }
        return j;
    }
};




题：实现strStr()
实现strStr()函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

方法一：暴力破解 时间复杂度O(M*N)
class Solution {
public:
    int strStr(string haystack, string needle) {
        if( !needle.size() ) return 0;
        int i =0, j=0;
        while(haystack[i]!='\0' && needle[j]!='\0')
        {
            if(haystack[i] == needle[j]){
                i++;
                j++;
            }
            else
            {
                i = i-j+1;
                j=0;
            }
        }
        if( needle[j] == '\0' ) return i-j;
        return -1;
    }
};

方法二：KMP解法
class Solution {
     vector<int> getnext(string str)
        {
            int len=str.size();
            vector<int> next;
            next.push_back(-1);//next数组初值为-1
            int j=0,k=-1;
            while(j<len-1)
            {
                if(k==-1||str[j]==str[k])//str[j]后缀 str[k]前缀
                {
                    j++;
                    k++;
                    if(str[j]!=str[k])
                        next.push_back(k);
                    else
                        next.push_back(next[k]);
                }
                else
                    k=next[k];
            }
            return next;
        }

public:
    int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        
        int i=0;//源串
        int j=0;//子串
        int len1=haystack.size();
        int len2=needle.size();
        vector<int> next;
        next=getnext(needle);
        while((i<len1)&&(j<len2))
        {
            if((j==-1)||(haystack[i]==needle[j]))
            {
                i++;
                j++;
            }
            else
            {
                j=next[j];//获取下一次匹配的位置
            }
        }
        if(j==len2)
            return i-j;
        
        return -1;
    }
};




题：两数相除
给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

下面代码的思路，可以简单概括为： 60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == 0) return 0;
        if(divisor == 1) return dividend;
        if(divisor == -1){
            if(dividend>INT_MIN) return -dividend;// 只要不是最小的那个整数，都是直接返回相反数就好啦
            return INT_MAX;// 是最小的那个，那就返回最大的整数啦
        }
        long a = dividend;
        long b = divisor;
        int sign = 1; 
        if((a>0&&b<0) || (a<0&&b>0)){
            sign = -1;
        }
        a = a>0?a:-a;
        b = b>0?b:-b;
        long res = div(a,b);
        if(sign>0)return res>INT_MAX?INT_MAX:res;
        return -res;
    }
    int div(long a, long b){  // 似乎精髓和难点就在于下面这几句
        if(a<b) return 0;
        long count = 1;
        long tb = b; // 在后面的代码中不更新b
        while((tb+tb)<=a){
            count = count + count; // 最小解翻倍
            tb = tb+tb; // 当前测试的值也翻倍
        }
        return count + div(a-tb,b);
    }
};




题：串联所有单词的字串
给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> result;
        if(words.size() == 0) return result;

        int word_size = words[0].size();
        int word_num = words.size();
        unordered_map<string, int> m1;
        for(int i = 0; i < word_num; i++)
            m1[words[i]]++;
        
        unordered_map<string, int> m2;
        for(int i = 0; (i+word_num*word_size) <= s.size(); i++)
        {
            int j = 0;
            for(j = i; j < i+word_num*word_size; j = j+word_size)
            {
                string tmpStr = s.substr(j, word_size);
                if(m1[tmpStr] == 0)
                    break;
                m2[tmpStr]++;
                if(m1[tmpStr] < m2[tmpStr])
                    break;
            }
            if(j == i+word_num*word_size)
                result.push_back(i);
            m2.clear();
        }
        return result;
    }
};




题：下一个排列
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

思路：
如果当前排列是124653,找它的下一个排列的方法是，从这个序列中从右至左找第一个左邻小于右邻的数，
如果找不到，则所有排列求解完成，如果找得到则说明排列未完成。
本例中将找到46,计4所在的位置为i,找到后不能直接将46位置互换，而又要从右到左到第一个比4大的数，
本例找到的数是5，其位置计为j，将i与j所在元素交换125643,
然后将i+1至最后一个元素从小到大排序得到125346，这就是124653的下一个排列。

解法：
class Solution {
public:
	void nextPermutation(vector<int>& nums) {
		int pos = nums.size() - 1;
		while (pos > 0 && nums[pos] <= nums[pos - 1])
			pos--;
		reverse(nums.begin() + pos, nums.end());  //逆序
		if (pos > 0){
			int start = pos;
			for (; start < nums.size(); start++){ //寻找第一个大于nums[pos - 1]的数
				if (nums[start] > nums[pos - 1]){
					swap(nums[start], nums[pos - 1]); //交换
					break;
				}
			}
		}
	}
};

稍微改进下, 寻找第一个大于nums[pos - 1]的数原来为线性时间复杂度, 可以改用二分查找, 这里使用STL标准库upper_bound()
class Solution {
public:
	void nextPermutation(vector<int>& nums) {
		int pos = nums.size() - 1;
		while (pos > 0 && nums[pos] <= nums[pos - 1])
			pos--;
		reverse(nums.begin() + pos, nums.end());  //逆序
		if(pos > 0){
			auto iter = upper_bound(nums.begin() + pos, nums.end(), nums[pos - 1]);//使用upper_bound找到遍历过的数中第一个比num[pos-1]大的数
			swap(*iter, nums[pos - 1]);
		}
	}
};




题：最长有效括号
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
例：输入: "(()"，输出: 2

方法一：动态规划
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0, n = s.length();
        vector<int> dp(n, 0);
        for (int i = 1; i < n; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = max(maxans, dp[i]);
            }
        }
        return maxans;
    }
};

方法二：栈
class Solution {
public:
    int longestValidParentheses(string s) {
        int ansmax = 0;
        stack<int> stk;
        stk.push(-1);
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '(')
                stk.push(i);
            else{
                stk.pop();
                if(stk.empty())
                    stk.push(i);
                else
                    ansmax = max(ansmax, i-stk.top());
            }
        }
        return ansmax;
    }
};

方法三：正向逆向结合法
class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0, right = 0, maxlength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = max(maxlength, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
        for (int i = (int)s.length() - 1; i >= 0; i--) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = max(maxlength, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxlength;
    }
};




题：搜索旋转排序数组
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。

方法：二分搜索
可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置
分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。
这启示我们可以在常规二分搜索的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，
并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};





题：在排序数组中查找元素的第一个和最后一个位置
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 [-1, -1]。

方法：先找左边界再找右边界
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> ans(2,-1);
        if(nums.empty()) return ans;
        int l = 0, r = nums.size()-1;
        while(l < r)
        {
            int mid = (l+r)/2;
            if(nums[mid] >= target)
                r = mid;
            else
                l = mid+1;
        }
        if(nums[l] != target) return ans;
        int start = l;

        l = 0;
        r = nums.size()-1;
        while(l < r)
        {
            int mid = (l+r+1)/2;
            if(nums[mid] <= target)
                l = mid;
            else
                r = mid-1;
        }
        if(nums[l] != target) return ans;
        int end = r;
        ans[0] = start;
        ans[1] = end;
        return ans;
    }
};




题：搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1, ans = n;
        while (left <= right) {
            int mid = ((right - left) >> 1) + left;
            if (target <= nums[mid]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
};





题：有效的数独
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

方法：一次迭代
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int row[9][9] = {0};
        int col[9][9] = {0};
        int box[9][9] = {0};

        for(int i = 0; i < 9; i++)
        {
            for(int j = 0; j < 9; j++)
            {
                if(board[i][j] != '.')
                {
                    int val = board[i][j] - '1';
                    int box_index = (i/3)*3 + j/3;
                    if(row[i][val] == 0 && col[j][val] == 0 && box[box_index][val] == 0)
                    {
                        row[i][val] = 1;
                        col[j][val] = 1;
                        box[box_index][val] = 1;
                    }
                    else
                        return false;
                } 
            }
        }
        return true;
    }
};




题：解数独
编写一个程序，通过填充空格来解决数独问题。
一个数独的解法需遵循如下规则：
数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 '.' 表示。

方法：递归+回溯
class Solution {
    public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board,0,0);
    }

    bool backtrack(vector<vector<char>>& board, int row, int col){
        if(col == 9)
            return backtrack(board,row+1,0);

        if(row == 9)
            return true;

        for(int i = row; i < 9; i++){
            for(int j = col; j < 9; j++){
                if(board[i][j] != '.'){
                    return backtrack(board, i, j + 1);
                }
                for(char ch = '1'; ch <= '9'; ch++){
                    if(!isValid(board, i, j, ch))
                        continue;
                    board[i][j] = ch;
                    if(backtrack(board, i, j + 1))
                        return true;
                    board[i][j] = '.';
                }
                return false;

            }
        }
        return false;
    }

    bool isValid(vector<vector<char>>& board, int row, int col, char ch){
        for(int i = 0; i < 9; i++){
            if(board[row][i] == ch) return false;
            if(board[i][col] == ch) return false;
            if(board[(row/3)*3 + i/3][(col/3)*3 + i%3] == ch) return false;
        }
        return true;
    }
};


方法二：理解通了也好写
class Solution {
private:
    int row[9][9];
    int col[9][9];
    int box[3][3][9];
    bool valid;
    vector<pair<int, int>> spaces;
public:

    void dfs(vector<vector<char>>& board, int pos)
    {
        if(pos == spaces.size())
        {
            valid = true;
            return;
        }

        auto [i, j] = spaces[pos];
        for(int digit = 0; digit < 9 && !valid; digit++)
        {
            if(!row[i][digit] && !col[j][digit] && !box[i/3][j/3][digit])
            {
                row[i][digit] = col[j][digit] = box[i/3][j/3][digit] = true;
                board[i][j] = digit + '0' + 1;
                dfs(board, pos+1);
                row[i][digit] = col[j][digit] = box[i/3][j/3][digit] = false;
            }
        }
    }

    void solveSudoku(vector<vector<char>>& board) {
        memset(row, false, sizeof(row));
        memset(col, false, sizeof(col));
        memset(box, false, sizeof(box));
        valid = false;

        for(int i = 0; i < 9; i++)
        {
            for(int j = 0; j < 9; j++)
            {
                if(board[i][j] == '.')
                    spaces.emplace_back(i,j);
                else{
                    int digit = board[i][j] - '0' - 1;
                    row[i][digit] = col[j][digit] = box[i/3][j/3][digit] = true;
                }
            }
        }
        dfs(board, 0);
    }
};






题：外观数列
给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。
注意：整数序列中的每一项将表示为一个字符串。

第一项是数字 1
描述前一项，这个数是 1 即 “一个 1 ”，记作 11
描述前一项，这个数是 11 即 “两个 1 ” ，记作 21
描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211
描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221

方法：
class Solution {
public:
    string countAndSay(int n) {
        string str = "1";
        for(int i = 2; i <= n; i++)
        {
            string build;
            char pre = str[0];
            char count = '1';
            for(int j = 1; j < str.size(); j++)
            {
                if(str[j] == pre)
                    count++;
                else{
                    build.push_back(count);
                    build.push_back(pre);
                    pre = str[j];
                    count = '1';
                }
            }
            build.push_back(count);
            build.push_back(pre);
            str = build;
        }
        return str;
    }
};




题：组合总和
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

方法一：
class Solution {
public:
    void dfs(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& combine, int idx) {
        if (idx == candidates.size()) {
            return;
        }
        if (target == 0) {
            ans.emplace_back(combine);
            return;
        }
        // 直接跳过
        dfs(candidates, target, ans, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] >= 0) {
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> combine;
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }
};

方法二：
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }

        // 这里i 依然从 startIndex开始，因为求的是组合，如果求的是排列，那么i每次都从0开始
        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i); // 关键点在这里，不用i+1了，表示可以重复读取当前的数
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates, target, 0, 0);
        return result;
    }
};






题：组合总和II
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
说明：
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。

上一道题的要求：
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

方法一：
class Solution {
private:
    vector<vector<int>> ans;
    vector<int> combination;

    void backtrack(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used)
    {
        if(sum > target)
            return;
        if(sum == target)
        {
            ans.push_back(combination);
            return;
        }

        for(int i = startIndex; i < candidates.size(); i++)
        {//used[i] == true,表示在同一树枝上用过， used[i] == false,表示在同一层上用过
            if(i > 0 && candidates[i] == candidates[i-1] && used[i-1] == false)
                continue;
            used[i] = true;
            combination.push_back(candidates[i]);
            sum += candidates[i];
            backtrack(candidates, target, sum, i+1, used);
            used[i] = false;
            sum -= candidates[i];
            combination.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, target, 0, 0, used);
        return ans;
    }
};

方法二：
class Solution {

private:
    vector<int> candidates;
    vector<vector<int>> res;
    vector<int> path;
public:
    void DFS(int start, int target) {
        if (target == 0) {
            res.push_back(path);
            return;
        }

        for (int i = start; i < candidates.size() && target - candidates[i] >= 0; i++) {
            if (i > start && candidates[i] == candidates[i - 1])
                continue;
            path.push_back(candidates[i]);
            // 元素不可重复利用，使用下一个即i+1
            DFS(i + 1, target - candidates[i]);
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {
        sort(candidates.begin(), candidates.end());
        this->candidates = candidates;
        DFS(0, target);
        return res;
    }
};






题：
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
要求：你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

//哈希表：支持快速查找的数据结构：给定一个元素，可以在O(1)的时间查找该元素是否在哈希表中

对于一个长度为 N 的数组，其中没有出现的最小正整数只能在 [1, N+1] 中。
这是因为如果 [1, N] 都出现了，那么答案是 N+1，否则答案是 [1, N] 中没有出现的最小正整数。
我们对数组进行遍历，对于遍历到的数 x，如果它在 [1, N] 的范围内，那么就将数组中的第 x-1个位置（注意：数组下标从0开始）
打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 N+1，否则答案是最小的没有打上标记的位置加 1。

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int& num: nums) {      //把不在[1,N]范围内的数修改为任意一个大于N的数(如N+1)。对数组第一次遍历，将零和负数修改为N+1
            if (num <= 0) {
                num = n + 1;
            }
        }
        for (int i = 0; i < n; ++i) {      //第二次遍历，将数x对应的位置x-1标记为负数，注意代码写法
            int num = abs(nums[i]);
            if (num <= n) {
                nums[num - 1] = -abs(nums[num - 1]);
            }
        }
        for (int i = 0; i < n; ++i) {    //第三次遍历，找出第一个大于0的数，其位置加1即为所求的未出现的最小正整数
            if (nums[i] > 0) {
                return i + 1;
            }
        }
        return n + 1;      //如果所有的数都是负数，那么代表 [1,N] 的数都出现了一次，此时未出现的最小正整数为n+1
    }
};





题：








